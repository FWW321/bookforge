---
description: 
globs: 
alwaysApply: true
---
# Rust General Programming Guide

## 1. Code Style Guidelines

### Code Formatting
- **Automatic Formatting**: Use the `rustfmt` tool to ensure consistent code formatting
- **Indentation Standards**: Consistently use 4 spaces for indentation, prohibit the use of tabs
- **Line Length Limit**: Single line code length should not exceed 100 characters, break lines appropriately when exceeded
- **Blank Line Usage**: Use appropriate blank lines to separate functions, structs, modules, and logical blocks
- **Bracket Style**: Opening bracket on the same line as the statement, closing bracket on its own line aligned with the corresponding keyword

### Naming Conventions
- **Variables and Functions**: Use `snake_case` naming style, names should clearly express their purpose
- **Types and Structs**: Use `PascalCase` naming style
- **Constants**: Use `SCREAMING_SNAKE_CASE` uppercase with underscores style
- **Module Names**: Use `snake_case` lowercase with underscores style
- **Lifetime Parameters**: Use short and meaningful names, typically single lowercase letters (`'a`, `'b`)
- **Generic Parameters**: Use concise uppercase letters (`T`, `U`, `V`) or descriptive names

### Clarity and Conciseness Requirements
- **Expressive Naming**: Variable names and function names should accurately express their purpose and intent
- **Avoid Abbreviations**: Use complete words unless they are widely recognized abbreviations
- **Logical Grouping**: Related code should be organized together, use blank lines to separate different logical blocks
- **Eliminate Duplication**: Eliminate code duplication through functions, macros, modules, etc.
- **Prefer Expressions**: Use expressions rather than statements when possible

### Code Structure Guidelines

#### Project Directory Structure
Recommended standard project structure organization:

```
src/
├── main.rs          # Application entry point
├── lib.rs           # Library root module
├── config/          # Configuration management module
│   ├── mod.rs       # Configuration module public interface
│   └── app_config.rs # Application configuration implementation
├── database/        # Database-related modules
│   ├── mod.rs       # Database module interface
│   ├── connection.rs # Database connection management
│   └── models.rs    # Data model definitions
└── services/        # Business logic service layer
    ├── mod.rs       # Service module interface
    ├── user_service.rs # User service implementation
    └── auth_service.rs # Authentication service implementation
```

#### File Responsibility Allocation
- **main.rs**: Application startup logic, command line argument parsing, dependency injection container initialization
- **lib.rs**: Define library public API, re-export core modules, set module visibility
- **config/mod.rs**: Configuration module unified interface, re-export configuration-related types and functions
- **config/app_config.rs**: Specific configuration structure definitions, configuration loading and validation logic
- **database/mod.rs**: Database module public interface, connection pool management, transaction processing abstraction
- **database/connection.rs**: Database connection establishment, configuration, connection pool implementation
- **database/models.rs**: Data model structure definitions, serialization/deserialization logic
- **services/mod.rs**: Service layer public interface, service registration and dependency management
- **services/user_service.rs**: User-related business logic, CRUD operation encapsulation
- **services/auth_service.rs**: Authentication authorization logic, token management, permission verification

#### Module Organization Principles
- **Group by Functional Domain**: Organize related functionality into the same module
- **Hierarchical Design**: Clear module hierarchy, avoid circular dependencies
- **Interface Isolation**: Each module provides a unified public interface through `mod.rs`
- **Dependency Direction**: Upper-level modules depend on lower-level modules, business logic depends on infrastructure
- **Testability**: Module design facilitates unit testing and integration testing

## 2. Ownership System and Memory Management

### Borrowing Rules Compliance
- **Principle of Least Privilege**: Use the minimum necessary borrowing permissions
- **Lifetime Clarity**: Ensure borrowing lifetimes are clear and explicit
- **Avoid Dangling References**: Prevent references from pointing to freed memory
- **Borrow Checker Friendly**: Write code that can pass the borrow checker

### Move Semantics Usage
- **Ownership Transfer**: Properly use move semantics to avoid unnecessary copying
- **Clone Strategy**: Use clone operations only when necessary
- **Reference Passing**: Prefer reference passing over value passing

### Smart Pointer Usage Guidelines
- **Box Use Cases**: Use for heap allocation and recursive data structures
- **Rc Usage Timing**: Use for shared ownership in single-threaded environments
- **Arc Thread Safety**: Use for shared ownership in multi-threaded environments
- **RefCell Interior Mutability**: Use for scenarios requiring runtime borrow checking

### RAII Pattern Application
- **Automatic Cleanup**: Use destructors to implement automatic resource cleanup
- **Scope Management**: Control resource lifetime through scope
- **Exception Safety**: Ensure resources can be properly released in exceptional situations
- **Resource Acquisition Is Initialization**: Acquire resources during construction, release during destruction

### Circular Reference Prevention
- **Weak Reference Usage**: Use `Weak` pointers to break circular references
- **Design Principles**: Avoid circular reference generation at design stage
- **Memory Leak Detection**: Regularly check for potential memory leaks

## 3. Error Handling Framework

### Explicit Error Handling
- **Result Type Usage**: Prefer using `Result` type for error handling
- **Option Type Application**: Use `Option` type for potentially null values
- **Error Chain Propagation**: Use the question mark operator (`?`) for error propagation
- **Early Return**: Return early when errors are detected

### Custom Error Design
- **Error Hierarchy**: Establish clear error type hierarchy
- **Context Information**: Provide sufficient context information to aid debugging
- **Error Classification**: Classify errors into recoverable and non-recoverable types
- **Error Conversion**: Provide conversion mechanisms between error types (implement `From` trait)

### Panic Handling Principles
- **Library Code Restrictions**: Avoid using `panic!` in library code
- **Application Boundaries**: Use `panic!` only at application boundaries
- **Clear Error Messages**: Provide clear panic error messages
- **Recovery Mechanisms**: Provide error recovery mechanisms when possible

## 4. Performance Optimization Strategies

### Zero-Cost Abstraction Principles
- **Iterator Optimization**: Prefer iterator chains over manual loops, compiler will optimize
- **Generic Monomorphization**: Utilize compile-time generic monomorphization for runtime zero cost
- **Inline Functions**: Use `#[inline]` optimization for small frequently called functions
- **Compile-Time Computation**: Push computations to compile time when possible

### Memory Layout Optimization
- **Struct Field Ordering**: Arrange fields in descending order of size to reduce memory alignment overhead
- **Stack vs Heap Choice**: Prefer stack allocation, use heap allocation only when necessary
- **Data Structure Selection**: Choose the most suitable data structure based on usage patterns
- **Cache Friendliness**: Consider data access patterns, optimize cache hit rates

### Algorithm Optimization Guidelines
- **Time Complexity Priority**: Choose algorithms with better time complexity
- **Pre-allocation Strategy**: Pre-allocate containers of known size
- **Lazy Computation**: Compute only when needed
- **Batch Operations**: Combine multiple small operations into batch operations

## 5. Concurrency and Parallel Programming

### Thread Safety Principles
- **Data Race Prevention**: Avoid data races and race conditions
- **Synchronization Primitive Selection**: Choose appropriate synchronization primitives (`Mutex`, `RwLock`, `Condvar`)
- **Deadlock Prevention**: Design to avoid deadlock generation
- **Atomic Operation Usage**: Use atomic types for simple operations

### Async Programming Patterns
- **async/await Syntax**: Correctly use async syntax
- **Future Composition**: Use macros like `join!`, `select!` to compose async operations
- **Error Propagation**: Correctly propagate errors in async contexts
- **Cancellation Mechanism**: Support cancellation of async operations

### Concurrency Model Selection
- **Task Parallelism**: Use thread pools for CPU-intensive tasks
- **IO Concurrency**: Use async IO for IO-intensive tasks
- **Message Passing**: Use channels for inter-thread communication
- **Shared State**: Use shared state cautiously, prefer message passing

## 6. Functional Programming Guidelines

### Immutability Principles
- **Default Immutable**: Prefer immutable variables, use mutability only when necessary
- **Function Side Effect Control**: Minimize function side effects, prefer writing pure functions
- **State Isolation**: Isolate mutable state to specific boundaries

### Iterator Pattern Usage
- **Lazy Evaluation**: Utilize iterator laziness to optimize performance
- **Iterator Chaining**: Build clear iterator processing chains
- **Custom Iterators**: Implement `Iterator` trait for custom types
- **Collection Strategy**: Choose appropriate collection strategies and target types

### Higher-Order Function Application
- **Functions as Parameters**: Design higher-order functions that accept functions as parameters
- **Closure Design**: Choose appropriate closure capture strategies based on needs
- **Function Composition**: Build complex processing pipelines through function composition

## 7. Modularization Organization Principles

### Module Structure Design
- **Functional Grouping**: Organize code into different modules by functionality
- **Hierarchical Architecture**: Establish clear module hierarchy
- **Interface Abstraction**: Define clear module interfaces
- **Dependency Management**: Control dependencies between modules

### Visibility Control
- **Principle of Minimal Exposure**: Only expose necessary public interfaces
- **Hide Internal Implementation**: Hide module internal implementation details
- **Re-export Strategy**: Use re-exports appropriately to simplify APIs

### Code Reuse Strategies
- **Common Modules**: Extract common functionality into shared modules
- **Trait Abstraction**: Use traits to define common behavior
- **Generic Programming**: Use generics to improve code reusability

## 8. Comments and Documentation Standards

### Documentation Comment Standards
- **Function Description**: Every public function, struct, enum must have clear functional description
- **Parameter Description**: Detailed description of each parameter's type, purpose, and constraints
- **Return Value Description**: Clearly describe the meaning and possible states of return values
- **Error Conditions**: List possible error conditions and exceptional behavior
- **Usage Examples**: Provide typical usage examples and expected results
- **Performance Notes**: Describe time and space complexity for performance-sensitive functions

### Inline Comment Guidelines
- **Explain Complex Logic**: Provide explanations for complex algorithms and business logic
- **Mark TODOs**: Use `TODO`, `FIXME`, `NOTE` etc. for marking

- **Explain Design Decisions**: Explain why specific implementation approaches were chosen